<html><!-- Online page at https://registry.terraform.io/providers/hashicorp/external/latest/docs/data-sources/external --><head>
                <title>external</title>
                <meta charset="utf-8"/>
                <link href="../../../../../../style.css" rel="stylesheet"/>
            </head>
            <body>
                <h1 id="external">external</h1>

<p>The <code>external</code> data source allows an external program implementing a specific protocol (defined below) to act as a data source, exposing arbitrary data for use elsewhere in the Terraform configuration.</p>

<p><strong>Warning</strong> This mechanism is provided as an "escape hatch" for exceptional situations where a first-class Terraform provider is not more appropriate. Its capabilities are limited in comparison to a true data source, and implementing a data source via an external program is likely to hurt the portability of your Terraform configuration by creating dependencies on external programs and libraries that may not be available (or may need to be used differently) on different operating systems.</p>

<p><strong>Warning</strong> Terraform Enterprise does not guarantee availability of any particular language runtimes or external programs beyond standard shell utilities, so it is not recommended to use this data source within configurations that are applied within Terraform Enterprise.</p>

<a class="dashAnchor" name="//apple_ref/cpp/Section/Example%20Usage"></a><h2 id="example-usage">Example Usage</h2>

<div class="codehilite"><pre><span></span><code><span class="kr">data</span><span class="w"> </span><span class="nc">"external"</span><span class="w"> </span><span class="nv">"example"</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="na">program</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="s2">"bash", "${path.module}/example-data-source.sh"</span><span class="p">]</span><span class="w"></span>

<span class="w">  </span><span class="nb">query</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="c1"></span>
<span class="c1">    # arbitrary map from strings to strings, passed</span>
<span class="c1">    # to the external program as the data query.</span>
<span class="w">    </span><span class="na">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"abc123"</span><span class="w"></span>
<span class="w">    </span><span class="na">baz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"def456"</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>

<a class="dashAnchor" name="//apple_ref/cpp/Section/External%20Program%20Protocol"></a><h2 id="external-program-protocol">External Program Protocol</h2>

<p>The external program described by the <code>program</code> attribute must implement a
specific protocol for interacting with Terraform, as follows.</p>

<p>The program must read all of the data passed to it on <code>stdin</code>, and parse
it as a JSON object. The JSON object contains the contents of the <code>query</code>
argument and its values will always be strings.</p>

<p>The program must then produce a valid JSON object on <code>stdout</code>, which will
be used to populate the <code>result</code> attribute exported to the rest of the
Terraform configuration. This JSON object must again have all of its
values as strings. On successful completion it must exit with status zero.</p>

<p>If the program encounters an error and is unable to produce a result, it
must print a human-readable error message (ideally a single line) to <code>stderr</code>
and exit with a non-zero status. Any data on <code>stdout</code> is ignored if the
program returns a non-zero status.</p>

<p>All environment variables visible to the Terraform process are passed through
to the child program.</p>

<p>Terraform expects a data source to have <em>no observable side-effects</em>, and will
re-run the program each time the state is refreshed.</p>

<!-- schema generated by tfplugindocs -->

<a class="dashAnchor" name="//apple_ref/cpp/Section/Schema"></a><h2 id="schema">Schema</h2>

<a class="dashAnchor" name="//apple_ref/cpp/Section/Required"></a><h3 id="required">Required</h3>

<ul>
<li><code>program</code> (List of String) A list of strings, whose first element is the program to run and whose subsequent elements are optional command line arguments to the program. Terraform does not execute the program through a shell, so it is not necessary to escape shell metacharacters nor add quotes around arguments containing spaces.</li>
</ul>

<a class="dashAnchor" name="//apple_ref/cpp/Section/Optional"></a><h3 id="optional">Optional</h3>

<ul>
<li><code>query</code> (Map of String) A map of string values to pass to the external program as the query arguments. If not supplied, the program will receive an empty object as its input.</li>
<li><code>working_dir</code> (String) Working directory of the program. If not supplied, the program will run in the current directory.</li>
</ul>

<a class="dashAnchor" name="//apple_ref/cpp/Section/Read-Only"></a><h3 id="read-only">Read-Only</h3>

<ul>
<li><code>id</code> (String) The id of the data source. This will always be set to <code>-</code></li>
<li><code>result</code> (Map of String) A map of string values returned from the external program.</li>
</ul>

<a class="dashAnchor" name="//apple_ref/cpp/Section/Processing%20JSON%20in%20shell%20scripts"></a><h2 id="processing-json-in-shell-scripts">Processing JSON in shell scripts</h2>

<p>Since the external data source protocol uses JSON, it is recommended to use
the utility <a href="https://stedolan.github.io/jq/"><code>jq</code></a> to translate to and from
JSON in a robust way when implementing a data source in a shell scripting
language.</p>

<p>The following example shows some input/output boilerplate code for a
data source implemented in bash:</p>

<div class="codehilite"><pre><span></span><code><span class="ch">#!/bin/bash</span>

<span class="c1"># Exit if any of the intermediate steps fail</span>
<span class="nb">set</span> -e

<span class="c1"># Extract "foo" and "baz" arguments from the input into</span>
<span class="c1"># FOO and BAZ shell variables.</span>
<span class="c1"># jq will ensure that the values are properly quoted</span>
<span class="c1"># and escaped for consumption by the shell.</span>
<span class="nb">eval</span> <span class="s2">"</span><span class="k">$(</span>jq -r <span class="s1">'@sh "FOO=\(.foo) BAZ=\(.baz)"'</span><span class="k">)</span><span class="s2">"</span>

<span class="c1"># Placeholder for whatever data-fetching logic your script implements</span>
<span class="nv">FOOBAZ</span><span class="o">=</span><span class="s2">"</span><span class="nv">$FOO</span><span class="s2"> </span><span class="nv">$BAZ</span><span class="s2">"</span>

<span class="c1"># Safely produce a JSON object containing the result value.</span>
<span class="c1"># jq will ensure that the value is properly quoted</span>
<span class="c1"># and escaped to produce a valid JSON string.</span>
jq -n --arg foobaz <span class="s2">"</span><span class="nv">$FOOBAZ</span><span class="s2">"</span> <span class="s1">'{"foobaz":$foobaz}'</span>
</code></pre></div>

            
        
    </body></html>